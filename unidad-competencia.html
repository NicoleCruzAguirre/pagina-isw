<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unidad de Competencia 1 - Ingeniería de Software</title>
    <link rel="stylesheet" href="style-unidad-competencia.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<body>

    <!-- Encabezado principal -->
    <!-- <header class="hero">
        <div class="hero-content">
            <h1>Unidad de Competencia 1</h1>
            <p>Disciplina de Ingeniería de Software en el campo de la Computación</p>
        </div>
    </header>-->

    <header>
      <a href="index.html" class="logo">← Regresar</a>
    </header>

    <main>

        <section class="hero hero-unidad-1">
          <div class="hero-content">
            <h1>Unidad de Competencia I</h1>
            <p>Disciplina de Ingeniería de Software en el campo de la Computación</p>
          </div>
        </section>

        <!-- Introducción -->
        <section class="intro">
            <h2>¿Qué es la Ingeniería de Software?</h2>
            <p>
                La Ingeniería de Software es una disciplina que aplica principios, métodos y buenas prácticas para desarrollar 
                software de manera sistemática, controlada y medible. Va mucho más allá de programar: involucra diseño, 
                pruebas, mantenimiento, gestión de procesos, calidad, herramientas y fundamentos teóricos.
            </p>
        </section>

        <hr class="divider">

        <!-- Áreas SWEBOK -->
        <section class="section">
            <h2>Áreas Fundamentales según SWEBOK</h2>

            <div class="cards">

                <div class="card">
                    <h3><i class="icon fas fa-file-alt"></i>1. Requisitos de software</h3>
                    <p>Definición y análisis de lo que el software debe hacer. Incluye requisitos funcionales, no funcionales, validación y gestión.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-drafting-compass"></i>2. Diseño de software</h3>
                    <p>Arquitectura, componentes, patrones de diseño y estructuras que hacen al software mantenible y escalable.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-code"></i>3. Construcción (Implementación)</h3>
                    <p>Codificación, pruebas unitarias, depuración e integración de componentes.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-vial"></i>4. Pruebas de software</h3>
                    <p>Validación del cumplimiento de requisitos, pruebas unitarias, integración, sistema y regresión.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-tools"></i>5. Mantenimiento</h3>
                    <p>Modificaciones para corregir errores, mejorar rendimiento o adaptarse a nuevos requisitos.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-server"></i>6. Gestión de la configuración</h3>
                    <p>Control de versiones, cambios y artefactos del proyecto para evitar pérdidas y confusiones.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-project-diagram"></i>7. Proceso de Ingeniería de Software</h3>
                    <p>Modelos como ágil, cascada o iterativo, planificación y mejora continua del proceso.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-laptop-code"></i>8. Herramientas y Métodos</h3>
                    <p>IDE, frameworks, automatización, metodologías ágiles y herramientas CASE.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-check-circle"></i>9. Calidad del software</h3>
                    <p>Control de calidad, métricas, auditorías y verificación/validación.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-user-tie"></i>10. Práctica profesional</h3>
                    <p>Ética, roles, comunicación, documentación y buenas prácticas profesionales.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-coins"></i>11. Economía del software</h3>
                    <p>Estimación de costos, retorno de inversión y planificación de recursos.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-database"></i>12. Fundamentos de computación</h3>
                    <p>Estructuras de datos, algoritmos, teoría de la computación.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-square-root-alt"></i>13. Fundamentos matemáticos</h3>
                    <p>Lógica, probabilidad, combinatoria, grafos, estadística.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-cogs"></i>14. Fundamentos de ingeniería</h3>
                    <p>Principios para el desarrollo disciplinado, cuantificable y medible.</p>
                </div>


            </div>
        </section>

        <hr class="divider">

        <!-- Importancia -->
        <section class="section">
            <h2>Importancia de estas disciplinas</h2>
            <ul class="list">
                <li>Profesionalizan el desarrollo de software.</li>
                <li>Permiten crear software confiable, seguro y mantenible.</li>
                <li>Facilitan estimaciones reales de tiempo, costo y recursos.</li>
                <li>Aseguran trabajo en equipo ordenado y sostenible.</li>
                <li>Vinculan teoría y práctica de forma organizada.</li>
            </ul>
        </section>

        <hr class="divider">

        <!-- Tendencias -->
        <section class="section">
            <h2>Tendencias Actuales en Ingeniería de Software</h2>

            <div class="cards">

                <div class="card trend">
                    <h3><i class="icon fas fa-robot"></i>1. IA aplicada al desarrollo</h3>
                    <p>Modelos inteligentes que ayudan en diseño, pruebas y generación de código.</p>
                </div>

                <div class="card trend">
                    <h3><i class="icon fas fa-cogs"></i>2. Automatización (CI/CD)</h3>
                    <p>Pipelines automáticos con agentes inteligentes que toman decisiones.</p>
                </div>

                <div class="card trend">
                    <h3><i class="icon fas fa-layer-group"></i>3. Microservicios</h3>
                    <p>Arquitecturas modulares, escalables y mantenibles.</p>
                </div>

                <div class="card trend">
                    <h3><i class="icon fas fa-cloud"></i>4. Cloud computing</h3>
                    <p>GitOps, infraestructura como código, seguridad integrada y observabilidad avanzada.</p>
                </div>

                <div class="card trend">
                    <h3><i class="icon fas fa-rocket"></i>5. DevOps</h3>
                    <p>Cultura colaborativa para lanzar versiones más rápido y con menos errores.</p>
                </div>

                <div class="card trend">
                    <h3><i class="icon fas fa-shield-alt"></i>6. Software seguro</h3>
                    <p>Prácticas para proteger datos y sistemas desde el diseño.</p>
                </div>

                <div class="card trend">
                    <h3><i class="icon fas fa-chart-bar"></i>7. Software basado en datos</h3>
                    <p>Sistemas que aprenden y se adaptan a los usuarios mediante análisis de datos.</p>
                </div>

                <div class="card trend">
                    <h3><i class="icon fas fa-broadcast-tower"></i>8. Sistemas inteligentes (IoT)</h3>
                    <p>Software para dispositivos conectados: autos, sensores, hogares inteligentes.</p>
                </div>

                <div class="card trend">
                    <h3><i class="icon fas fa-puzzle-piece"></i>9. Low-code / No-code</h3>
                    <p>Crear apps sin programar, acelerando el desarrollo.</p>
                </div>

                <div class="card trend">
                    <h3><i class="icon fas fa-atom"></i>10. Computación cuántica</h3>
                    <p>Tecnología emergente con potencial para resolver problemas enormes.</p>
                </div>

            </div>
        </section>

        <hr class="divider">

        <!-- Tipos de Software -->
        <section class="section">
            <h2>Concepto y Tipos de Software</h2>

            <p>El software es un conjunto de instrucciones, datos y reglas que permiten al hardware realizar tareas.</p>

            <div class="cards">

                <div class="card">
                    <h3><i class="icon fas fa-desktop"></i>Software de sistema</h3>
                    <p>Sistemas operativos, controladores y utilidades básicas.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-mobile-alt"></i>Software de aplicación</h3>
                    <p>Programas para el usuario final: navegadores, juegos, apps móviles.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-microchip"></i>Software embebido</h3>
                    <p>Software integrado en dispositivos: relojes, electrodomésticos, vehículos.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-stopwatch"></i>Software en tiempo real</h3>
                    <p>Sistemas que deben responder en tiempos estrictos.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-brain"></i>Software con IA</h3>
                    <p>Modelos de aprendizaje automático integrados en aplicaciones.</p>
                </div>
            </div>
        </section>

        <hr class="divider">

        <!-- Atributos -->
        <section class="section">
            <h2>Atributos de Calidad del Software</h2>
            <ul class="list">
                <li>Adecuación funcional</li>
                <li>Compatibilidad</li>
                <li>Usabilidad</li>
                <li>Fiabilidad</li>
                <li>Eficiencia</li>
                <li>Mantenibilidad</li>
                <li>Seguridad</li>
                <li>Portabilidad</li>
                <li>Sostenibilidad y escalabilidad</li>
            </ul>
        </section>

        <hr class="divider">

        <!-- Unidad de Competencia 2 -->
         <section class="hero hero-unidad-2">
          <div class="hero-content">
            <h1>Unidad de Competencia II</h1>
            <p>Etapas del Ciclo de Vida del Software</p>
            <p>
                El ciclo de vida del software describe todas las fases que recorre un sistema desde que nace la idea hasta 
                que deja de utilizarse. Su propósito es organizar el trabajo, facilitar la gestión del proyecto y asegurar 
                calidad en cada entrega.
            </p>
          </div>
        </section>

        <!-- Etapas del SDLC -->
        <section class="section">
            <h2>Etapas del Ciclo de Vida del Software</h2>

            <div class="cards">

                <div class="card">
                    <h3><i class="icon fas fa-clipboard-list"></i>Planificación / Requisitos</h3>
                    <p>
                        Identificación de necesidades, análisis de viabilidad, definición del alcance, elaboración del cronograma 
                        y documentación formal de requisitos funcionales y no funcionales.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-search"></i>Análisis</h3>
                    <p>
                        Refinamiento de requisitos, modelado de procesos, reglas de negocio, especificación funcional y no 
                        funcional, y documentación técnica detallada.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-pencil-ruler"></i>Diseño</h3>
                    <p>
                        Definición de la arquitectura del sistema, diseño modular, base de datos, diagramas UML y selección 
                        de tecnologías y patrones de diseño.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-keyboard"></i>Codificación / Implementación</h3>
                    <p>
                        Desarrollo del software, integración de componentes, uso de estándares de programación y ejecución 
                        de pruebas unitarias durante la construcción del sistema.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-vial"></i>Pruebas</h3>
                    <p>
                        Validación mediante pruebas unitarias, de integración, sistema y aceptación. Corrección de errores y 
                        verificación del cumplimiento de requisitos establecidos.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-upload"></i>Despliegue / Instalación</h3>
                    <p>
                        Instalación del software en producción, migración de datos, configuración del ambiente, capacitación 
                        a usuarios y entrega de documentación final.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-tools"></i>Mantenimiento</h3>
                    <p>
                        Correcciones, mejoras, adaptaciones y actualizaciones continuas para mantener el sistema operativo, 
                        seguro y alineado a nuevas necesidades.
                    </p>
                </div>

            </div>
        </section>

        <hr class="divider">

        <!-- Modelos de Desarrollo -->
        <section class="section">
            <h2>Modelos de Desarrollo de Software</h2>

            <div class="cards">

                <div class="card">
                    <h3><i class="icon fas fa-stream"></i>Ciclo de vida lineal</h3>
                    <p>
                        Modelo simple y secuencial, adecuado para proyectos pequeños con requisitos estables y bien definidos.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-water"></i>Cascada (Waterfall)</h3>
                    <p>
                        Cada fase se completa totalmente antes de iniciar la siguiente. Funciona bien cuando los requisitos no cambian.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-check-double"></i>Modelo en V</h3>
                    <p>
                        Relaciona cada etapa de desarrollo con una etapa de prueba, poniendo énfasis en verificación y validación.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-water-lower"></i>Sashimi</h3>
                    <p>
                        Variante del modelo en cascada donde las fases se superponen, permitiendo mayor flexibilidad y revisión continua.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-project-diagram"></i>Cascada con subproyectos</h3>
                    <p>
                        Divide el sistema en módulos independientes, cada uno tratado como un mini proyecto completo con su propio ciclo.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-redo-alt"></i>Modelo iterativo</h3>
                    <p>
                        Desarrollo en ciclos repetidos. Cada iteración mejora el sistema basándose en retroalimentación temprana.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-sync-alt"></i>Modelo incremental</h3>
                    <p>
                        El sistema se construye en partes funcionales. Ideal para entregar valor rápidamente y adaptarse a cambios.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-drafting-compass"></i>Modelo evolutivo</h3>
                    <p>
                        El software crece y se adapta con el tiempo abordando requisitos poco claros desde el inicio.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-recycle"></i>Modelo espiral</h3>
                    <p>
                        Centrado en la gestión de riesgos, combina iteraciones con análisis profundo en cada ciclo.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-running"></i>Metodologías ágiles</h3>
                    <p>
                        Entregas cortas, colaboración continua, flexibilidad y adaptación al cambio mediante iteraciones rápidas.
                    </p>
                </div>

            </div>
        </section>

        <hr class="divider">

        <section class="hero hero-unidad-3">
          <div class="hero-content">
            <h1>Unidad de Competencia III</h1>
            <p>Corrientes en el Desarrollo de Software</p>
          </div>
        </section>

        <!-- Unidad de Competencia III -->
        <section class="section">

            <div class="cards">

                <!-- Modelo clásico / Cascada -->
                <div class="card">
                    <h3><i class="icon fas fa-water"></i>Modelo clásico / Secuencial (Cascada)</h3>
                    <p>
                        En este enfoque, el desarrollo se organiza en fases secuenciales: requisitos, diseño, 
                        implementación, pruebas, despliegue y mantenimiento. Cada fase se completa antes de pasar 
                        a la siguiente.
                    </p>
                    <p>
                        Es el primer modelo formal de ciclo de vida del software, documentado por Winston W. Royce 
                        en 1970.
                    </p>
                    <p><strong>Ventajas:</strong> estructura clara, fases bien definidas, abundante documentación, ideal para requisitos estables.</p>
                    <p><strong>Desventajas:</strong> poca flexibilidad, errores detectados tarde, difícil adaptación a cambios.</p>
                </div>

                <!-- Modelo Evolutivo / Prototipos -->
                <div class="card">
                    <h3><i class="icon fas fa-sync-alt"></i>Modelo Evolutivo / Prototipos</h3>
                    <p>
                        En escenarios con requisitos incompletos o inciertos, este modelo permite construir prototipos 
                        tempranos que se refinan iterativamente hasta obtener el producto final.
                    </p>
                    <p>
                        Facilita la retroalimentación continua, la adaptación a cambios y mejora progresiva del sistema.
                    </p>
                    <p><strong>Útil en:</strong> requisitos cambiantes, falta de claridad inicial, proyectos exploratorios.</p>
                </div>

                <!-- Modelo Incremental -->
                <div class="card">
                    <h3><i class="icon fas fa-layer-group"></i>Modelo Incremental</h3>
                    <p>
                        El sistema se divide en módulos y se construye mediante “incrementos”, donde cada entrega agrega 
                        funciones nuevas y produce una versión parcial funcional.
                    </p>
                    <p>
                        Cada incremento puede probarse, usarse y evaluarse, permitiendo obtener feedback temprano.
                    </p>
                    <p><strong>Ventajas:</strong> entregas tempranas, menor riesgo, más flexibilidad, ajuste continuo de requisitos.</p>
                    <p><strong>Desventajas:</strong> requiere arquitectura modular y buena planificación para evitar complejidad en la integración.</p>
                </div>

                <!-- Desarrollo Ágil -->
                <div class="card">
                    <h3><i class="icon fas fa-bolt"></i>Desarrollo Ágil</h3>
                    <p>
                        Conjunto de metodologías basadas en iteraciones cortas, entregas frecuentes, colaboración intensa 
                        y adaptación constante a los cambios.
                    </p>
                    <p>
                        A diferencia del modelo en cascada, no depende de requisitos fijos al inicio; estos pueden evolucionar 
                        mientras el software se desarrolla.
                    </p>
                    <p>
                        Se centra en retroalimentación continua, mejora constante y entrega rápida de valor.
                    </p>
                    <p><strong>Ideal para:</strong> proyectos con alta incertidumbre, innovación, aplicaciones web o móviles, 
                        entornos cambiantes.</p>
                </div>

                

            </div>
        </section>

                <!-- ¿Qué se entiende por modelo de desarrollo? -->
        <div class="card">
            <h3><i class="icon fas fa-question-circle"></i>¿Qué se entiende por “modelo de desarrollo de software”?</h3>
            <p>
                En ingeniería de software, un modelo de desarrollo es un marco que define cómo se organizan 
                las fases, tareas, roles y entregables para construir un software.
            </p>
            <p>
                Cada modelo organiza el trabajo de forma diferente: puede ser secuencial, iterativo, incremental 
                o basado en prototipos, entre otros enfoques.
            </p>
        </div>

        <hr class="divider">

        <!-- Roles típicos -->
        <section class="section">
            <h2 class="section-title">Roles típicos en un equipo de desarrollo</h2>
            <p>
                Independientemente del modelo de ciclo de vida, los equipos de desarrollo suelen integrar 
                varios roles con responsabilidades definidas. En equipos pequeños, una persona puede asumir 
                varios roles; en proyectos grandes, estos se especializan.
            </p>

            <div class="cards">
                <div class="card">
                    <h3><i class="icon fas fa-user-tie"></i>Gerente / Jefe de proyecto</h3>
                    <p>
                        Planifica, coordina recursos, controla tiempos y supervisa que se cumplan los objetivos del proyecto.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-clipboard-list"></i>Analista de requisitos / Analista de negocio</h3>
                    <p>
                        Obtiene y define los requisitos del cliente, traduciendo necesidades del negocio en 
                        especificaciones técnicas claras.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-drafting-compass"></i>Arquitecto / Diseñador de software</h3>
                    <p>
                        Define la arquitectura general del sistema, modularidad, escalabilidad y toma decisiones 
                        técnicas clave para el proyecto.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-code"></i>Desarrolladores</h3>
                    <p>
                        Implementan el código, construyen funcionalidades, integran módulos y corrigen errores.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-vial"></i>Tester / QA</h3>
                    <p>
                        Realiza pruebas, asegura la calidad del producto y detecta errores antes de entregarlo al usuario.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-server"></i>DevOps / Configuración / Infraestructura</h3>
                    <p>
                        Gestiona entornos, servidores, versiones, despliegues y mantenimiento continuo.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-user-check"></i>Roles ágiles</h3>
                    <p>
                        En metodologías ágiles surgen roles adicionales como:
                        <strong>Product Owner</strong> (representa al negocio) y
                        <strong>Scrum Master</strong> (facilitador del equipo).
                    </p>
                </div>
            </div>
        </section>

        <hr class="divider">

        <!-- Productos / artefactos -->
        <section class="section">
            <h2 class="section-title">Productos y artefactos generados en el desarrollo</h2>
            <p>
                Cada modelo de desarrollo produce diferentes artefactos: documentación formal, versiones 
                incrementales, prototipos o entregas funcionales frecuentes.
            </p>

            <div class="cards">

                <div class="card">
                    <h3><i class="icon fas fa-file-alt"></i>Modelos Secuenciales (Cascada)</h3>
                    <p>
                        Generan documentación formal por fases: requisitos, diseño, código, pruebas y manuales.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-cubes"></i>Modelos Iterativos e Incrementales</h3>
                    <p>
                        Producen versiones parciales funcionales (incrementos) que evolucionan gradualmente hacia 
                        el producto final.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-shapes"></i>Modelos Evolutivos / Prototipos</h3>
                    <p>
                        Generan prototipos tempranos usados para validar requisitos con clientes y refinar el 
                        sistema de forma iterativa.
                    </p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-sync"></i>Modelos Ágiles</h3>
                    <p>
                        Entregan software funcional de manera frecuente en ciclos cortos, favoreciendo retroalimentación 
                        continua y ajustes rápidos.
                    </p>
                </div>

            </div>
        </section>

        <hr class="divider">

        <!-- Ventajas y retos -->
        <section class="section">
            <h2 class="section-title">Ventajas y retos según los modelos</h2>

            <div class="cards">

                <div class="card">
                    <h3><i class="icon fas fa-water"></i>Waterfall / Secuenciales</h3>
                    <p><strong>Ventajas:</strong> claridad del proceso, documentación completa, fácil de gestionar, ideal para requisitos estables.</p>
                    <p><strong>Retos:</strong> poca flexibilidad, adaptación tardía a cambios, validación final demorada.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-layer-group"></i>Incremental / Iterativo / Evolutivo</h3>
                    <p><strong>Ventajas:</strong> entregas tempranas, reducción de riesgos, flexibilidad, retroalimentación constante.</p>
                    <p><strong>Retos:</strong> gestión compleja de versiones, integración frecuente, posible menor documentación.</p>
                </div>

                <div class="card">
                    <h3><i class="icon fas fa-bolt"></i>Modelos Ágiles</h3>
                    <p><strong>Ventajas:</strong> fuerte adaptabilidad, entregas continuas, colaboración cercana con el cliente.</p>
                    <p><strong>Retos:</strong> requiere alta participación del negocio, menor predictibilidad de tiempos y costos.</p>
                </div>

            </div>
        </section>

        <hr class="divider">

        <!-- Combinación de roles, modelos y artefactos -->
        <section class="section">
            <h2 class="section-title">Cómo se combinan roles, modelos y artefactos</h2>
            <p>
                La elección del modelo influye directamente en la estructura del equipo y en los artefactos generados.
                Los modelos ágiles, por ejemplo, incorporan roles como Product Owner y Scrum Master, mientras que 
                los modelos secuenciales se apoyan más en documentación formal.
            </p>
            <p>
                Elegir el modelo adecuado depende del tamaño del proyecto, claridad de requisitos, tiempo disponible, 
                complejidad técnica, recursos y necesidad de flexibilidad.
            </p>
</section>



    </main>

</body>
</html>
